library ieee;
use ieee.std_logic_1164.all;

entity spi_master is 
    port(
        clk   : in std_logic;     -- System clock
        reset : in std_logic;     -- Reset signal
        miso  : in std_logic;     -- Master In Slave Out, input from slave
        mosi  : out std_logic;    -- Master Out Slave In, output to slave
        cs    : out std_logic     -- Chip select, output to slave
    );
end entity spi_master;

architecture logic of spi_master is 

    signal sclk_internal : std_logic := '0';    -- SPI clock generated by master
    signal clk_counter   : integer range 0 to 4 := 0;

    signal datatransmitted : std_logic_vector(7 downto 0) := "00000101";  -- Data to transmit
    signal datareceived    : std_logic_vector(7 downto 0) := "00000000";  -- Data received from slave
begin
    -- Clock generation process (SPI clock, SCLK)
    process(clk, reset)
    begin
        if (reset = '1') then
            cs <= '1';  -- Set chip select high (inactive) during reset
            clk_counter <= 0;
            datareceived <= (others => '0');  -- Clear datareceived register
            sclk_internal <= '0';  -- Reset the SPI clock
        elsif rising_edge(clk) then
            if clk_counter = 4 then  -- Divide the system clock by 5 to get slower SPI clock
                clk_counter <= 0;
                sclk_internal <= not sclk_internal;  -- Toggle the SPI clock
            else 
                clk_counter <= clk_counter + 1;
            end if;
        end if;
    end process;

    -- Transmitting data (on the falling edge of the SPI clock, sclk_internal)
    process(sclk_internal)
    begin
        if falling_edge(sclk_internal) then  -- In Mode 0, data is shifted out on falling edge
            mosi <= datatransmitted(7);  -- Send the MSB first
            datatransmitted <= datatransmitted(6 downto 0) & '0';  -- Shift left for next bit
        end if;
    end process;

    -- Receiving data (on the rising edge of the SPI clock, sclk_internal)
    process(sclk_internal)
    begin
        if rising_edge(sclk_internal) then  -- In Mode 0, data is sampled on the rising edge
            datareceived <= datareceived(6 downto 0) & miso;  -- Shift left and capture MISO
        end if;
    end process;

end architecture logic;
